<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\work\sensorberg\windows10-sdk\sensorbergsdk\sensorbergsdkbackground\backgroundengine.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using SensorbergSDK;
using SensorbergSDK.Internal;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Windows.ApplicationModel.Background;
using Windows.Devices.Bluetooth;
using Windows.Devices.Bluetooth.Background;
using Windows.UI.Notifications;
using MetroLog;
using SensorbergSDK.Internal.Data;
using SensorbergSDK.Internal.Services;

namespace SensorbergSDKBackground
{
    /// &lt;summary&gt;
    /// BackgroundEngine resolves actions from BluetoothLEAdvertisementWatcherTriggerDetails object
    /// and resolves delayed actions. This is not part of the public API. Making modifications into
    /// background tasks is not required in order to use the SDK.
    /// &lt;/summary&gt;
    public class BackgroundEngine : IDisposable
    {
        private static readonly ILogger logger = LogManagerFactory.DefaultLogManager.GetLogger&lt;BackgroundEngine&gt;();
        private const int ExitEventDelayInSeconds = 13;
        private const int KillTimerDelayInMilliseconds = 200;

        public event EventHandler&lt;BackgroundWorkerType&gt; Finished;

        private SDKEngine SdkEngine { get; }
        private IList&lt;Beacon&gt; Beacons { get; set; }
        private readonly IList&lt;BeaconEventArgs&gt; _beaconArgs;
        private Timer _killTimer;
        private int _unsolvedCounter;
        private bool _readyToFinish = false;
        private int _finishingRounds = 5;
        private AppSettings AppSettings { get; set; }

        public event EventHandler&lt;BeaconAction&gt; BeaconActionResolved
        {
            add { SdkEngine.BeaconActionResolved += value; }
            remove { SdkEngine.BeaconActionResolved -= value; }
        }

        public event EventHandler&lt;string&gt; FailedToResolveBeaconAction
        {
            add { SdkEngine.FailedToResolveBeaconAction += value; }
            remove { SdkEngine.FailedToResolveBeaconAction -= value; }
        }

        public event EventHandler&lt;bool&gt; LayoutValidityChanged
        {
            add { SdkEngine.LayoutValidityChanged += value; }
            remove { SdkEngine.LayoutValidityChanged -= value; }
        }

        public BackgroundEngine()
        {
            SdkEngine = new SDKEngine(false);
            _beaconArgs = new List&lt;BeaconEventArgs&gt;();
//            SdkEngine.Resolver.RequestQueueCountChanged += OnRequestQueueCountChanged;
            SdkEngine.BeaconActionResolved += OnBeaconActionResolvedAsync;
        }

        /// &lt;summary&gt;
        /// Initializes BackgroundEngine
        /// &lt;/summary&gt;
        public async Task InitializeAsync()
        {
            await SdkEngine.InitializeAsync();
            AppSettings = await ServiceManager.SettingsManager.GetSettings();

            //TODO verfiy
            if (BackgroundTaskManager.CheckIfBackgroundFilterUpdateIsRequired())
            {
                ToastNotification toastNotification = NotificationUtils.CreateToastNotification(&quot;New beacon signature available&quot;, &quot;Launch the application to update&quot;);
                NotificationUtils.ShowToastNotification(toastNotification);
            }
        }

        /// &lt;summary&gt;
        /// Resolves beacons, which triggered the background task.
        /// &lt;/summary&gt;
        public async Task ResolveBeaconActionsAsync(List&lt;Beacon&gt; beacons, int outOfRangeDb)
        {
            logger.Trace(&quot;ResolveBeaconActionsAsync&quot;);

            Beacons = beacons;
            if (Beacons.Count &gt; 0)
            {
                await AddBeaconsToBeaconArgsAsync(outOfRangeDb);
            }

            if (_beaconArgs.Count &gt; 0)
            {
                // Resolve new events
                _unsolvedCounter = _beaconArgs.Count;

                foreach (var beaconArg in _beaconArgs)
                {
                    await SdkEngine.ResolveBeaconAction(beaconArg);
                }
            }
            Finished?.Invoke(this, BackgroundWorkerType.ADVERTISEMENT_WORKER);
        }

        /// &lt;summary&gt;
        /// Processes the delayed actions and executes them as necessary.
        /// &lt;/summary&gt;
        public async Task ProcessDelayedActionsAsync()
        {
            await SdkEngine.ProcessDelayedActionsAsync();
            await SdkEngine.FlushHistory();
            Finished?.Invoke(this, BackgroundWorkerType.TIMED_WORKER);
        }


        /// &lt;summary&gt;
        /// Generates BeaconArgs from beacon events.
        /// For instance if a beacon is seen for the first time, BeaconArgs with enter type is generated
        /// &lt;/summary&gt;
        private async Task AddBeaconsToBeaconArgsAsync(int outOfRangeDb)
        {
            logger.Trace(&quot;AddBeaconsToBeaconArgsAsync&quot;);
            foreach (var beacon in Beacons)
            {
                BackgroundEvent history = await ServiceManager.StorageService.GetLastEventStateForBeacon(beacon.Pid);

                if (history == null || history.LastEvent == BeaconEventType.Exit ||
                    (!IsOutOfRange(outOfRangeDb, beacon) &amp;&amp; history.EventTime.AddMilliseconds(AppSettings.BeaconExitTimeout) &lt; DateTimeOffset.Now))
                {
                    // No history for this beacon. Let&#39;s save it and add it to event args array for solving.
                    AddBeaconArgs(beacon, BeaconEventType.Enter);
                    await ServiceManager.StorageService.SaveBeaconEventState(beacon.Pid, BeaconEventType.Enter);
#if LOUD_DEBUG
                    ToastNotification toastNotification = NotificationUtils.CreateToastNotification(&quot;Enter Beacon&quot;, _beacons[0].Id1 + &quot; &quot; + _beacons[0].BeaconId2 + &quot; &quot; + _beacons[0].BeaconId3);
                    NotificationUtils.ShowToastNotification(toastNotification);
#endif
                }
                else if (history.LastEvent == BeaconEventType.Enter)
                {
                    if (IsOutOfRange(outOfRangeDb, beacon))
                    {
                        // Exit event
                        AddBeaconArgs(beacon, BeaconEventType.Exit);
                        await ServiceManager.StorageService.SaveBeaconEventState(beacon.Pid, BeaconEventType.Exit);
#if LOUD_DEBUG
                            ToastNotification toastNotification = NotificationUtils.CreateToastNotification(&quot;Exit Beacon&quot;, _beacons[0].Id1 + &quot; &quot; + _beacons[0].BeaconId2 + &quot; &quot; + _beacons[0].BeaconId3);
                            NotificationUtils.ShowToastNotification(toastNotification);
#endif
                    }
                }
            }
        }

        private static bool IsOutOfRange(int outOfRangeDb, Beacon beacon)
        {
            return beacon.RawSignalStrengthInDBm == outOfRangeDb;
        }

        private void AddBeaconArgs(Beacon beacon, BeaconEventType eventType)
        {
            var args = new BeaconEventArgs();
            args.Beacon = beacon;
            args.EventType = eventType;
            _beaconArgs.Add(args);
        }

        /// &lt;summary&gt;
        /// Observers changes in the RequestQueue. When the queue is empty, kill timer is started which will finish background task
        /// &lt;/summary&gt;
        private void OnRequestQueueCountChanged(object sender, int e)
        {
            logger.Trace(&quot;BackgroundEngine.OnRequestQueueCountChanged(): &quot; + e);

            if (e &gt; 0)
            {
                if (_killTimer != null)
                {
                    _killTimer.Dispose();
                    _killTimer = null;
                }
            }
            else
            {
                _killTimer = new Timer(OnKill, null, KillTimerDelayInMilliseconds, KillTimerDelayInMilliseconds);  
            }
        }

        /// &lt;summary&gt;
        /// Handles BeaconActions that are resolved in the SDKEngine.
        /// All resolved actions are stored into local database. And the UI app will show actions to the user.
        /// When the UI app is not running, toast notification is shown for the user.
        /// &lt;/summary&gt;
        private void OnBeaconActionResolvedAsync(object sender, BeaconAction beaconAction)
        {
            logger.Trace(&quot;BackgroundEngine.OnBeaconActionResolvedAsync()&quot;);
        }

        private void OnKill(object state)
        {
            if (_readyToFinish)
            {
                Dispose();
                return;
            }
            
            // Finish when there are no more unresolved actions or timer has been called 5 times
            // (1 second in total)
            if (SdkEngine.UnresolvedActionCount &lt;= 0 || _finishingRounds-- &lt;= 0)
            {
                // Signals that we are ready to finish. Waits one more cycle to ensure everything
                // has been finished.
                _readyToFinish = true;
            }
        }
        
        /// &lt;summary&gt;
        /// Finishes background processing and releases all resources
        /// &lt;/summary&gt;

        public void Dispose()
        {
            try
            {
                _killTimer?.Dispose();
                _killTimer = null;

                SdkEngine.BeaconActionResolved -= OnBeaconActionResolvedAsync;
            }
            finally
            {
                SdkEngine.Dispose();
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[42,20,42,21,0],[42,22,42,62,0],[42,63,42,64,0],[47,17,47,18,0],[47,19,47,66,0],[47,67,47,68,0],[48,20,48,21,0],[48,22,48,69,0],[48,70,48,71,0],[53,17,53,18,0],[53,19,53,60,0],[53,61,53,62,0],[54,20,54,21,0],[54,22,54,63,0],[54,64,54,65,0],[173,9,173,10,0],[174,13,174,81,0],[176,13,176,23,0],[177,13,177,14,0],[178,17,178,40,0],[179,17,179,18,0],[180,21,180,42,0],[181,21,181,39,0],[182,17,182,18,0],[183,13,183,14,0],[185,13,185,14,0],[186,17,186,114,0],[187,13,187,14,0],[188,9,188,10,0],[201,9,201,10,0],[202,13,202,32,0],[203,13,203,14,0],[204,17,204,27,0],[205,17,205,24,0],[210,13,210,81,0],[211,13,211,14,0],[214,17,214,39,0],[215,13,215,14,0],[216,9,216,10,0],[223,9,223,10,0],[225,13,225,14,0],[226,17,226,39,0],[227,17,227,35,0],[229,17,229,79,0],[230,13,230,14,0],[232,13,232,14,0],[233,17,233,37,0],[234,13,234,14,0],[235,9,235,10,0],[75,13,75,14,0],[76,17,76,167,0],[77,17,77,76,0],[111,9,111,10,0],[112,13,112,58,0],[113,13,113,44,0],[114,13,114,71,0],[115,9,115,10,0],[143,21,143,22,0],[145,25,145,69,0],[146,25,146,116,0],[151,21,151,22,0],[30,39,30,43,1],[31,41,31,45,1],[31,46,31,50,1],[37,43,37,47,1],[37,48,37,52,1],[41,17,41,18,1],[41,19,41,59,1],[41,60,41,61,1],[35,9,35,45,1],[36,9,36,42,1],[57,9,57,34,1],[58,9,58,10,1],[59,13,59,46,1],[60,13,60,55,1],[62,13,62,75,1],[63,9,63,10,1],[157,9,157,10,1],[158,13,158,66,1],[159,9,159,10,1],[162,9,162,10,1],[163,13,163,46,1],[164,13,164,34,1],[165,13,165,40,1],[166,13,166,35,1],[167,9,167,10,1],[196,9,196,10,1],[197,13,197,76,1],[198,9,198,10,1],[24,9,24,116,1],[69,9,69,10,1],[70,13,70,47,1],[71,13,71,78,1],[74,13,74,81,1],[78,13,78,14,1],[79,9,79,10,1],[85,9,85,10,1],[86,13,86,55,1],[88,13,88,31,1],[89,13,89,35,1],[90,13,90,14,1],[91,17,91,65,1],[92,13,92,14,1],[94,13,94,39,1],[95,13,95,14,1],[97,17,97,54,1],[99,17,99,24,1],[99,43,99,54,1],[99,26,99,39,1],[100,17,100,18,1],[101,21,101,68,1],[102,17,102,18,1],[99,40,99,42,1],[103,13,103,14,1],[104,13,104,79,1],[105,9,105,10,1],[123,9,123,10,1],[124,13,124,57,1],[125,13,125,20,1],[125,36,125,43,1],[125,22,125,32,1],[126,13,126,14,1],[127,17,127,118,1],[129,17,130,148,1],[131,17,131,18,1],[133,21,133,66,1],[134,21,134,113,1],[139,17,139,18,1],[140,22,140,69,1],[141,17,141,18,1],[142,21,142,60,1],[152,17,152,18,1],[153,13,153,14,1],[125,33,125,35,1],[154,9,154,10,1]]);
    </script>
  </body>
</html>