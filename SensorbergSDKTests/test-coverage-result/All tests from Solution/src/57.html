<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\work\sensorberg\windows10-sdk\sensorbergsdk\internal\services\storageservice.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Created by Kay Czarnotta on 10.03.2016
// 
// Copyright (c) 2016,  Sensorberg
// 
// All rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Windows.Data.Json;
using Windows.Storage;
using SensorbergSDK.Internal.Data;
using SensorbergSDK.Internal.Utils;
using SensorbergSDK.Services;

namespace SensorbergSDK.Internal.Services
{
    public class StorageService : IStorageService
    {
        private const string KeyLayoutHeaders = &quot;layout_headers&quot;;
        private const string KeyLayoutContent = &quot;layout_content.cache&quot;; // Cache file
        private const string KeyLayoutRetrievedTime = &quot;layout_retrieved_time&quot;;
        private readonly Dictionary&lt;string, IList&lt;HistoryAction&gt;&gt; historyActionsCache;
        private const int MAX_RETRIES= 5;

        public int RetryCount { get; set; } = 3;

        public IStorage Storage { [DebuggerStepThrough] get; [DebuggerStepThrough] set; }

        public StorageService(bool createdOnForeground = true)
        {
            //Ensures that database tables are created
            Storage = new FileStorage() {Background = !createdOnForeground};
            historyActionsCache = new Dictionary&lt;string, IList&lt;HistoryAction&gt;&gt;();
        }

        public async Task InitStorage()
        {
           await Storage.InitStorage();
        }


        /// &lt;summary&gt;
        /// Checks whether the given API key is valid or not.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;apiKey&quot;&gt;The API key to validate.&lt;/param&gt;
        /// &lt;returns&gt;The validation result.&lt;/returns&gt;
        public async Task&lt;ApiKeyValidationResult&gt; ValidateApiKey(string apiKey)
        {
            ResponseMessage responseMessage = null;

            responseMessage = await ExecuteCall(async () =&gt; await ServiceManager.ApiConnction.RetrieveLayoutResponse(SDKData.Instance, apiKey));

            if (responseMessage != null &amp;&amp; responseMessage.IsSuccess)
            {

                return string.IsNullOrEmpty(responseMessage.Content) || responseMessage.Content.Length &lt; Constants.MinimumLayoutContentLength
                    ? ApiKeyValidationResult.Invalid
                    : ApiKeyValidationResult.Valid;
            }
            return responseMessage.NetworResult == NetworkResult.NetworkError ? ApiKeyValidationResult.NetworkError : ApiKeyValidationResult.UnknownError;
        }


        private async Task WaitBackoff(int currentRetries)
        {
            await Task.Delay((int) Math.Pow(2, currentRetries + 1)*100);
        }

        public async Task&lt;LayoutResult&gt; RetrieveLayout()
        {
            ResponseMessage responseMessage = await ExecuteCall(async () =&gt; await ServiceManager.ApiConnction.RetrieveLayoutResponse(SDKData.Instance));
            if (responseMessage != null &amp;&amp; responseMessage.IsSuccess)
            {
                Layout layout = null;
                string headersAsString = Helper.StripLineBreaksAndExcessWhitespaces(responseMessage.Header);
                string contentAsString = Helper.StripLineBreaksAndExcessWhitespaces(responseMessage.Content);
                contentAsString = Helper.EnsureEncodingIsUTF8(contentAsString);
                DateTimeOffset layoutRetrievedTime = DateTimeOffset.Now;

                if (contentAsString.Length &gt; Constants.MinimumLayoutContentLength)
                {
                    try
                    {
                        JsonValue content = JsonValue.Parse(contentAsString);
                        layout = Layout.FromJson(headersAsString, content.GetObject(), layoutRetrievedTime);
                        Debug.WriteLine(&quot;LayoutManager: new Layout received: Beacons: &quot; + layout.AccountBeaconId1s.Count + &quot; Actions :&quot; + layout.ResolvedActions.Count);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(&quot;LayoutManager.RetrieveLayout(): Failed to parse layout: &quot; + ex);
                        layout = null;
                    }
                }

                if (layout != null)
                {
                    // Store the parsed layout
                    await SaveLayoutToLocalStorage(headersAsString, contentAsString, layoutRetrievedTime);
                    return new LayoutResult() {Layout = layout, Result = NetworkResult.Success};
                }
            }
            else
            {
               Layout layout= await LoadLayoutFromLocalStorage();
                return new LayoutResult() {Result = layout != null ? NetworkResult.Success : NetworkResult.NetworkError, Layout = layout};
            }

            return new LayoutResult() {Result = responseMessage != null ? responseMessage.NetworResult : NetworkResult.UnknownError};
        }

        public Task&lt;AppSettings&gt; RetrieveAppSettings()
        {
            throw new NotImplementedException();
        }

        public async Task&lt;bool&gt; FlushHistory()
        {
            try
            {
                History history = new History();
                history.actions = await Storage.GetUndeliveredActions();
                history.events = await Storage.GetUndeliveredEvents();

                if ((history.events != null &amp;&amp; history.events.Count &gt; 0) || (history.actions != null &amp;&amp; history.actions.Count &gt; 0))
                {
                    var responseMessage = await ExecuteCall(async () =&gt; await ServiceManager.ApiConnction.SendHistory(history));

                    if (responseMessage.IsSuccess)
                    {
                        if ((history.events != null &amp;&amp; history.events.Count &gt; 0))
                        {
                            await Storage.SetEventsAsDelivered();
                        }

                        if (history.actions != null &amp;&amp; history.actions.Count &gt; 0)
                        {
                            await Storage.SetActionsAsDelivered();
                        }
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(&quot;Error while sending history: &quot; + ex.Message);
            }
            return false;
        }



        /// &lt;summary&gt;
        /// Saves the strings that make up a layout.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;headers&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;content&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;layoutRetrievedTime&quot;&gt;&lt;/param&gt;
        private async Task SaveLayoutToLocalStorage(string headers, string content, DateTimeOffset layoutRetrievedTime)
        {
            if (await StoreData(KeyLayoutContent, content))
            {
                ApplicationData.Current.LocalSettings.Values[KeyLayoutHeaders] = headers;
                ApplicationData.Current.LocalSettings.Values[KeyLayoutRetrievedTime] = layoutRetrievedTime;
            }
        }

        /// &lt;summary&gt;
        /// Saves the given data to the specified file.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;fileName&quot;&gt;The file name of the storage file.&lt;/param&gt;
        /// &lt;param name=&quot;data&quot;&gt;The data to save.&lt;/param&gt;
        /// &lt;returns&gt;True, if successful. False otherwise.&lt;/returns&gt;
        private async Task&lt;bool&gt; StoreData(string fileName, string data)
        {
            bool success = false;

            try
            {
                var storageFile = await ApplicationData.Current.LocalFolder.CreateFileAsync(fileName, CreationCollisionOption.ReplaceExisting);
                await FileIO.AppendTextAsync(storageFile, data);
                success = true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(&quot;LayoutManager.StoreData(): Failed to save content: &quot; + ex);
            }

            return success;
        }

        /// &lt;summary&gt;
        /// Tries to load the layout from the local storage.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A layout instance, if successful. Null, if not found.&lt;/returns&gt;
        public async Task&lt;Layout&gt; LoadLayoutFromLocalStorage()
        {
            Layout layout = null;
            string headers = string.Empty;
            string content = string.Empty;
            DateTimeOffset layoutRetrievedTime = DateTimeOffset.Now;

            if (ApplicationData.Current.LocalSettings.Values.ContainsKey(KeyLayoutHeaders))
            {
                headers = ApplicationData.Current.LocalSettings.Values[KeyLayoutHeaders].ToString();
            }

            if (ApplicationData.Current.LocalSettings.Values.ContainsKey(KeyLayoutRetrievedTime))
            {
                layoutRetrievedTime = (DateTimeOffset)ApplicationData.Current.LocalSettings.Values[KeyLayoutRetrievedTime];
            }

            try
            {
                var contentFile = await ApplicationData.Current.LocalFolder.TryGetItemAsync(KeyLayoutContent);

                if (contentFile != null)
                {
                    content = await FileIO.ReadTextAsync(contentFile as IStorageFile);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(&quot;LayoutManager.LoadLayoutFromLocalStorage(): Failed to load content: &quot; + ex);
            }

            if (!string.IsNullOrEmpty(content))
            {
                content = Helper.EnsureEncodingIsUTF8(content);
                try
                {
                    JsonValue contentAsJsonValue = JsonValue.Parse(content);
                    layout = Layout.FromJson(headers, contentAsJsonValue.GetObject(), layoutRetrievedTime);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine(&quot;LayoutManager.LoadLayoutFromLocalStorage(): Failed to parse layout: &quot; + ex);
                }
            }

            if (layout == null)
            {
                // Failed to parse the layout =&gt; invalidate it
                await InvalidateLayout();
            }

            return layout;
        }

#region storage methods
        public async Task SaveHistoryAction(string uuid, string beaconPid, DateTimeOffset now, BeaconEventType beaconEventType)
        {
            await SaveHistoryActionRetry(uuid, beaconPid, now, beaconEventType, MAX_RETRIES);
        }

        private async Task SaveHistoryActionRetry(string uuid, string beaconPid, DateTimeOffset now, BeaconEventType beaconEventType, int retry)
        {
            if (retry &lt; 0)
            {
                return;
            }
            try
            {
                HistoryAction action = FileStorageHelper.ToHistoryAction(uuid, beaconPid, now, beaconEventType);
                if (!historyActionsCache.ContainsKey(uuid))
                {
                    historyActionsCache[uuid] = new List&lt;HistoryAction&gt;();
                }
                historyActionsCache[uuid].Add(action);
                await Storage.SaveHistoryAction(action);
            }
            catch (FileNotFoundException)
            {
                await SaveHistoryActionRetry(uuid, beaconPid, now, beaconEventType, --retry);
            }
        }

        public async Task SaveHistoryEvent(string pid, DateTimeOffset timestamp, BeaconEventType eventType)
        {
            await SaveHistoryEventRetry(pid, timestamp, eventType,MAX_RETRIES);
        }

        private async Task SaveHistoryEventRetry(string pid, DateTimeOffset timestamp, BeaconEventType eventType, int retry)
        {
            if (retry &lt; 0)
            {
                return;
            }
            try
            {
                await Storage.SaveHistoryEvents(FileStorageHelper.ToHistoryEvent(pid, timestamp, eventType));
            }
            catch (FileNotFoundException)
            {
                await SaveHistoryEventRetry(pid, timestamp, eventType, --retry);
            }
        }

        public async Task&lt;IList&lt;HistoryAction&gt;&gt; GetActions(string uuid, bool forceUpdate = false)
        {
            if (!forceUpdate)
            {
                if (historyActionsCache.ContainsKey(uuid))
                {
                    return historyActionsCache[uuid];
                }
            }
            return historyActionsCache[uuid] = await Storage.GetActions(uuid);
        }

        public async Task&lt;HistoryAction&gt; GetAction(string uuid, bool forceUpdate = false)
        {
            return (await GetActions(uuid,forceUpdate)).FirstOrDefault();
        }

        public async Task CleanDatabase()
        {
            await Storage.CleanDatabase();
        }

        public async Task&lt;IList&lt;DelayedActionData&gt;&gt; GetDelayedActions(int maxDelayFromNowInSeconds = 1000)
        {
           return await Storage.GetDelayedActions(maxDelayFromNowInSeconds);
        }

        public async Task SetDelayedActionAsExecuted(string id)
        {
            await Storage.SetDelayedActionAsExecuted(id);
        }

        public async Task SaveDelayedAction(ResolvedAction action, DateTimeOffset dueTime, string beaconPid, BeaconEventType eventTypeDetectedByDevice)
        {
            await SaveDelayedActionsRetry(action, dueTime, beaconPid, eventTypeDetectedByDevice,MAX_RETRIES);
        }

        private async Task SaveDelayedActionsRetry(ResolvedAction action, DateTimeOffset dueTime, string beaconPid, BeaconEventType eventTypeDetectedByDevice, int retry)
        {
            if (retry &lt; 0)
            {
                return;
            }
            try
            {
            await Storage.SaveDelayedAction(action, dueTime, beaconPid, eventTypeDetectedByDevice);
            }
            catch (FileNotFoundException)
            {
                await SaveDelayedActionsRetry(action, dueTime, beaconPid, eventTypeDetectedByDevice, --retry);
            }
        }

        public async Task&lt;BackgroundEvent&gt; GetLastEventStateForBeacon(string pid)
        {
            return await Storage.GetLastEventStateForBeacon(pid);
        }

        public async Task SaveBeaconEventState(string pid, BeaconEventType enter)
        {
            await SaveBeaconEventStateRetry(pid, enter,MAX_RETRIES);
        }

        private async Task SaveBeaconEventStateRetry(string pid, BeaconEventType enter, int retry)
        {
            if (retry &lt; 0)
            {
                return;
            }
            try
            {
                await Storage.SaveBeaconEventState(pid, enter);
            }
            catch (FileNotFoundException)
            {
                await SaveBeaconEventStateRetry(pid, enter, --retry);
            }
        }

        public async Task&lt;List&lt;BeaconAction&gt;&gt; GetActionsForForeground(bool doNotDelete = false)
        {
            List&lt;BeaconAction&gt; beaconActions = new List&lt;BeaconAction&gt;();
            List&lt;HistoryAction&gt; historyActions = await Storage.GetActionsForForeground(doNotDelete);
            foreach (HistoryAction historyAction in historyActions)
            {
                ResolvedAction action= ServiceManager.LayoutManager.GetAction(historyAction.eid);
                beaconActions.Add(action.BeaconAction);
            }

            return beaconActions;
        }

        #endregion

        /// &lt;summary&gt;
        /// Invalidates both the current and cached layout.
        /// &lt;/summary&gt;
        public async Task InvalidateLayout()
        {
            ApplicationData.Current.LocalSettings.Values[KeyLayoutHeaders] = null;
            ApplicationData.Current.LocalSettings.Values[KeyLayoutRetrievedTime] = null;

            try
            {
                var contentFile = await ApplicationData.Current.LocalFolder.TryGetItemAsync(KeyLayoutContent);

                if (contentFile != null)
                {
                    await contentFile.DeleteAsync();
                }
            }
            catch (Exception)
            {
            }
        }

        private async Task&lt;ResponseMessage&gt; ExecuteCall(Func&lt;Task&lt;ResponseMessage&gt;&gt; action)
        {

            bool networkError;
            int retries = 0;
            do
            {
                try
                {
                    ResponseMessage responseMessage = await action();
                    responseMessage.NetworResult = NetworkResult.Success;
                    return responseMessage;
                }
                catch (TimeoutException e)
                {
                    networkError = true;
                    Debug.WriteLine(&quot;timeout error while executing call: &quot; + e.Message);
                    await WaitBackoff(retries);
                }
                catch (IOException e)
                {
                    networkError = true;
                    Debug.WriteLine(&quot;Error while executing call: &quot; + e.Message);
                    await WaitBackoff(retries);
                }
                catch (HttpRequestException e)
                {
                    networkError = true;
                    Debug.WriteLine(&quot;Error while executing call: &quot; + e.Message);
                    await WaitBackoff(retries);
                }
                catch (Exception e)
                {
                    networkError = false;
                    Debug.WriteLine(&quot;Error while executing call: &quot; + e.Message);
                    await WaitBackoff(retries);
                }
                finally
                {
                    retries++;
                }
            } while (retries &lt; RetryCount);

            return new ResponseMessage() {NetworResult = networkError ? NetworkResult.NetworkError : NetworkResult.UnknownError};
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[30,38,30,42,0],[117,9,117,10,0],[118,13,118,49,0],[93,21,93,41,0],[94,21,94,22,0],[95,25,95,106,0],[96,25,96,39,0],[97,21,97,22,0],[106,13,106,14,0],[113,13,113,134,0],[148,13,148,33,0],[149,13,149,14,0],[150,17,150,79,0],[151,13,151,14,0],[188,13,188,33,0],[189,13,189,14,0],[190,17,190,93,0],[191,13,191,14,0],[226,13,226,33,0],[227,13,227,14,0],[228,17,228,110,0],[229,13,229,14,0],[239,17,239,37,0],[240,17,240,18,0],[241,21,241,114,0],[242,17,242,18,0],[263,13,263,14,0],[264,17,264,24,0],[276,13,276,42,0],[277,13,277,14,0],[278,17,278,94,0],[279,13,279,14,0],[290,13,290,14,0],[291,17,291,24,0],[297,13,297,42,0],[298,13,298,14,0],[299,17,299,81,0],[300,13,300,14,0],[321,9,321,10,0],[322,13,322,43,0],[323,9,323,10,0],[331,9,331,10,0],[332,13,332,58,0],[333,9,333,10,0],[336,9,336,10,0],[337,13,337,110,0],[338,9,338,10,0],[341,9,341,10,0],[342,13,342,27,0],[343,13,343,14,0],[344,17,344,24,0],[347,13,347,14,0],[348,13,348,100,0],[349,13,349,14,0],[350,13,350,42,0],[351,13,351,14,0],[352,17,352,111,0],[353,13,353,14,0],[354,9,354,10,0],[369,13,369,14,0],[370,17,370,24,0],[376,13,376,42,0],[377,13,377,14,0],[378,17,378,70,0],[379,13,379,14,0],[414,13,414,30,0],[415,13,415,14,0],[416,13,416,14,0],[432,17,432,43,0],[444,17,444,47,0],[433,17,433,18,0],[434,21,434,41,0],[435,21,435,89,0],[436,21,436,48,0],[437,17,437,18,0],[445,17,445,18,0],[446,21,446,41,0],[447,21,447,81,0],[448,21,448,48,0],[449,17,449,18,0],[30,33,30,37,1],[32,35,32,61,1],[32,62,32,88,1],[30,47,30,48,1],[34,9,34,63,1],[35,9,35,10,1],[37,13,37,77,1],[38,13,38,82,1],[39,9,39,10,1],[42,9,42,10,1],[43,12,43,40,1],[44,9,44,10,1],[53,9,53,10,1],[54,13,54,52,1],[56,13,56,61,1],[56,143,56,145,1],[58,13,58,70,1],[59,13,59,14,1],[61,17,63,52,1],[65,13,65,155,1],[66,9,66,10,1],[70,9,70,10,1],[71,13,71,73,1],[72,9,72,10,1],[75,9,75,10,1],[76,13,76,77,1],[76,151,76,153,1],[77,13,77,70,1],[78,13,78,14,1],[79,17,79,38,1],[80,17,80,109,1],[81,17,81,110,1],[82,17,82,80,1],[83,17,83,73,1],[85,17,85,83,1],[86,17,86,18,1],[88,21,88,22,1],[89,25,89,78,1],[90,25,90,109,1],[91,25,91,169,1],[92,21,92,22,1],[98,17,98,18,1],[100,17,100,36,1],[101,17,101,18,1],[103,21,103,107,1],[104,21,104,97,1],[108,13,108,14,1],[109,16,109,66,1],[110,17,110,139,1],[114,9,114,10,1],[122,9,122,10,1],[124,13,124,14,1],[125,17,125,49,1],[126,17,126,73,1],[127,17,127,71,1],[129,17,129,132,1],[130,17,130,18,1],[131,21,131,73,1],[131,127,131,129,1],[133,21,133,51,1],[134,21,134,22,1],[135,25,135,82,1],[136,25,136,26,1],[137,29,137,66,1],[138,25,138,26,1],[140,25,140,82,1],[141,25,141,26,1],[142,29,142,67,1],[143,25,143,26,1],[144,25,144,37,1],[146,17,146,18,1],[147,13,147,14,1],[152,13,152,26,1],[153,9,153,10,1],[164,9,164,10,1],[165,13,165,60,1],[166,13,166,14,1],[167,17,167,90,1],[168,17,168,108,1],[169,13,169,14,1],[170,9,170,10,1],[179,9,179,10,1],[180,13,180,34,1],[183,13,183,14,1],[184,17,184,144,1],[185,17,185,65,1],[186,17,186,32,1],[187,13,187,14,1],[193,13,193,28,1],[194,9,194,10,1],[201,9,201,10,1],[202,13,202,34,1],[203,13,203,43,1],[204,13,204,43,1],[205,13,205,69,1],[207,13,207,92,1],[208,13,208,14,1],[209,17,209,101,1],[210,13,210,14,1],[212,13,212,98,1],[213,13,213,14,1],[214,17,214,124,1],[215,13,215,14,1],[218,13,218,14,1],[219,17,219,111,1],[221,17,221,41,1],[222,17,222,18,1],[223,21,223,87,1],[224,17,224,18,1],[225,13,225,14,1],[231,13,231,48,1],[232,13,232,14,1],[233,17,233,64,1],[235,17,235,18,1],[236,21,236,77,1],[237,21,237,108,1],[238,17,238,18,1],[243,13,243,14,1],[245,13,245,32,1],[246,13,246,14,1],[248,17,248,42,1],[249,13,249,14,1],[251,13,251,27,1],[252,9,252,10,1],[256,9,256,10,1],[257,13,257,94,1],[258,9,258,10,1],[261,9,261,10,1],[262,13,262,27,1],[267,13,267,14,1],[268,17,268,113,1],[269,17,269,60,1],[270,17,270,18,1],[271,21,271,75,1],[272,17,272,18,1],[273,17,273,55,1],[274,17,274,57,1],[275,13,275,14,1],[280,9,280,10,1],[283,9,283,10,1],[284,13,284,80,1],[285,9,285,10,1],[288,9,288,10,1],[289,13,289,27,1],[294,13,294,14,1],[295,17,295,110,1],[296,13,296,14,1],[301,9,301,10,1],[304,9,304,10,1],[305,13,305,30,1],[306,13,306,14,1],[307,17,307,59,1],[308,17,308,18,1],[309,21,309,54,1],[311,13,311,14,1],[312,13,312,79,1],[313,9,313,10,1],[316,9,316,10,1],[317,13,317,74,1],[318,9,318,10,1],[326,9,326,10,1],[327,12,327,77,1],[328,9,328,10,1],[357,9,357,10,1],[358,13,358,66,1],[359,9,359,10,1],[362,9,362,10,1],[363,13,363,69,1],[364,9,364,10,1],[367,9,367,10,1],[368,13,368,27,1],[373,13,373,14,1],[374,17,374,64,1],[375,13,375,14,1],[380,9,380,10,1],[383,9,383,10,1],[384,13,384,73,1],[385,13,385,101,1],[386,13,386,20,1],[386,53,386,67,1],[386,22,386,49,1],[387,13,387,14,1],[388,17,388,98,1],[389,17,389,56,1],[390,13,390,14,1],[386,50,386,52,1],[392,13,392,34,1],[393,9,393,10,1],[401,9,401,10,1],[402,13,402,83,1],[403,13,403,89,1],[406,13,406,14,1],[407,17,407,111,1],[409,17,409,41,1],[410,17,410,18,1],[411,21,411,53,1],[412,17,412,18,1],[413,13,413,14,1],[417,9,417,10,1],[420,9,420,10,1],[423,13,423,29,1],[425,13,425,14,1],[427,17,427,18,1],[428,21,428,70,1],[429,21,429,74,1],[430,21,430,44,1],[438,17,438,38,1],[450,17,450,36,1],[439,17,439,18,1],[440,21,440,41,1],[441,21,441,81,1],[442,21,442,48,1],[443,17,443,18,1],[451,17,451,18,1],[452,21,452,42,1],[453,21,453,81,1],[454,21,454,48,1],[455,17,455,18,1],[457,17,457,18,1],[458,21,458,31,1],[459,17,459,18,1],[460,13,460,14,1],[460,15,460,44,1],[462,13,462,130,1],[463,9,463,10,1]]);
    </script>
  </body>
</html>