<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\work\sensorberg\windows10-sdk\sensorbergsdk\apikeyhelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using Windows.Web.Http.Headers;
using System.Threading.Tasks;
using Windows.Data.Json;
using Windows.Web.Http;
using Windows.Web.Http.Filters;
using SensorbergSDK.Internal.Services;

namespace SensorbergSDK
{
    public enum ApiKeyValidationResult
    {
        Valid,
        Invalid,
        NetworkError,
        UnknownError
    };

    public enum NetworkResult
    {
        Success,
        NetworkError,
        AuthenticationFailed,
        ParsingError,
        NoWindowsCampains,
        UnknownError
    };

    public class ApiKeyHelper
    {
        private const string LoginUrl = &quot;https://connect.sensorberg.com/api/user/login&quot;;
        private const string ApplicationsUrl = &quot;https://connect.sensorberg.com/api/applications/&quot;;
        private const string KeyEmail = &quot;email&quot;;
        private const string KeyPassword = &quot;password&quot;;
        private const string KeyResponse = &quot;response&quot;;
        private const string KeyAuthorizationToken = &quot;authToken&quot;;
        private const string KeyApiKey = &quot;apiKey&quot;;
        private const string KeyName = &quot;name&quot;;
        private const string KeyPlatform = &quot;platform&quot;;
        private const string PlatformValueWindows = &quot;windows&quot;;

        public string ApiKey
        {
            get;
            set;
        }

        public string ApplicationName
        {
            get;
            set;
        }

        /// &lt;summary&gt;
        /// Checks whether the given API key is valid or not.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;apiKey&quot;&gt;The API key to validate.&lt;/param&gt;
        /// &lt;returns&gt;The validation result.&lt;/returns&gt;
        public async Task&lt;ApiKeyValidationResult&gt; ValidateApiKey(string apiKey)
        {
            return await ServiceManager.StorageService.ValidateApiKey(apiKey);
        }

        /// &lt;summary&gt;
        /// Tries to fetch the API key from the server matching the given credentials.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;email&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;password&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;The fetching operation result. If successful, the API key is placed in the ApiKey property of this class.&lt;/returns&gt;
        public async Task&lt;NetworkResult&gt; FetchApiKeyAsync(string email, string password)
        {
            NetworkResult result;

            HttpBaseProtocolFilter httpBaseProtocolFilter = new HttpBaseProtocolFilter();
            httpBaseProtocolFilter.CacheControl.ReadBehavior = HttpCacheReadBehavior.MostRecent;
            httpBaseProtocolFilter.CacheControl.WriteBehavior = HttpCacheWriteBehavior.NoCache;
            HttpClient client = new HttpClient(httpBaseProtocolFilter);

            var keyValues = new List&lt;KeyValuePair&lt;string, string&gt;&gt;();
            keyValues.Add(new KeyValuePair&lt;string, string&gt;(KeyEmail, email));
            keyValues.Add(new KeyValuePair&lt;string, string&gt;(KeyPassword, password));
            HttpFormUrlEncodedContent formContent = new HttpFormUrlEncodedContent(keyValues);

            Uri uri = new Uri(LoginUrl);
            HttpResponseMessage response;

            try
            {
                response = await client.PostAsync(uri, formContent);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(&quot;ApiKeyHelper.FetchApiKeyAsync(): Network error: &quot; + ex.Message);
                return NetworkResult.NetworkError;
            }

            if (response.StatusCode == HttpStatusCode.Ok)
            {
                string responseAsString;

                try
                {
                    responseAsString = await response.Content.ReadAsStringAsync();
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine(&quot;ApiKeyHelper.FetchApiKeyAsync(): Network error: &quot; + ex.Message);
                    return NetworkResult.NetworkError;
                }

                JsonValue responseAsJsonValue;
                string authToken = string.Empty;

                try
                {
                    responseAsJsonValue = JsonValue.Parse(responseAsString);

                    if (responseAsJsonValue.ValueType == JsonValueType.Object)
                    {
                        var jsonObject = responseAsJsonValue.GetObject();
                        var responseObject = jsonObject.GetNamedObject(KeyResponse);
                        authToken = responseObject.GetNamedString(KeyAuthorizationToken);
                    }
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine(&quot;ApiKeyHelper.FetchApiKeyAsync(): Parsing error: &quot; + ex.Message);
                    return NetworkResult.ParsingError;
                }

                if (!string.IsNullOrEmpty(authToken))
                {
                    client = new HttpClient(httpBaseProtocolFilter);
                    uri = new Uri(ApplicationsUrl);
                    client.DefaultRequestHeaders.Authorization = new HttpCredentialsHeaderValue(authToken);

                    try
                    {
                        responseAsString = await client.GetStringAsync(uri);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine(&quot;ApiKeyHelper.FetchApiKeyAsync(): Network error: &quot; + ex.Message);
                        return NetworkResult.NetworkError;
                    }

                    responseAsJsonValue = JsonValue.Parse(responseAsString);
                    result = NetworkResult.NoWindowsCampains;

                    if (responseAsJsonValue.ValueType == JsonValueType.Array)
                    {
                        var applicationsArray = responseAsJsonValue.GetArray();

                        // We take the first Windows application from the list
                        foreach (IJsonValue applicationValue in applicationsArray)
                        {
                            if (applicationValue.ValueType == JsonValueType.Object)
                            {
                                JsonObject applicationObject = applicationValue.GetObject();

                                var apiKeyValue = applicationObject[KeyApiKey];
                                if (apiKeyValue.ValueType == JsonValueType.Null)
                                {
                                    continue;
                                }

                                var apiKey = applicationObject.GetNamedString(KeyApiKey);

                                string applicationName = applicationObject.GetNamedString(KeyName);
                                string platform = applicationObject.GetNamedString(KeyPlatform);

                                if (platform.ToLower().Equals(PlatformValueWindows.ToLower()))
                                {
                                    ApiKey = apiKey;
                                    ApplicationName = applicationName;
                                    result = NetworkResult.Success;
                                    break;
                                }
                            }
                        }
                    }
                }
                else // if (!string.IsNullOrEmpty(authToken)) - else
                {
                    result = NetworkResult.AuthenticationFailed;
                }
            }
            else if (response.StatusCode == HttpStatusCode.Unauthorized)
            {
                result = NetworkResult.AuthenticationFailed;
            }
            else
            {
                result = NetworkResult.NetworkError;
            }

            return result;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[45,13,45,17,0],[46,13,46,17,0],[51,13,51,17,0],[52,13,52,17,0],[61,9,61,10,0],[62,13,62,79,0],[63,9,63,10,0],[72,9,72,10,0],[75,13,75,90,0],[76,13,76,97,0],[77,13,77,96,0],[78,13,78,72,0],[80,13,80,70,0],[81,13,81,78,0],[82,13,82,84,0],[83,13,83,94,0],[85,13,85,41,0],[89,13,89,14,0],[90,17,90,69,0],[91,13,91,14,0],[92,13,92,33,0],[93,13,93,14,0],[94,17,94,117,0],[95,17,95,51,0],[98,13,98,58,0],[99,13,99,14,0],[103,17,103,18,0],[104,21,104,83,0],[105,17,105,18,0],[106,17,106,37,0],[107,17,107,18,0],[108,21,108,121,0],[109,21,109,55,0],[113,17,113,49,0],[116,17,116,18,0],[117,21,117,77,0],[119,21,119,79,0],[120,21,120,22,0],[121,25,121,74,0],[122,25,122,85,0],[123,25,123,90,0],[124,21,124,22,0],[125,17,125,18,0],[126,17,126,37,0],[127,17,127,18,0],[128,21,128,121,0],[129,21,129,55,0],[132,17,132,54,0],[133,17,133,18,0],[134,21,134,69,0],[135,21,135,52,0],[136,21,136,108,0],[139,21,139,22,0],[140,25,140,77,0],[141,21,141,22,0],[142,21,142,41,0],[143,21,143,22,0],[144,25,144,125,0],[145,25,145,59,0],[148,21,148,77,0],[149,21,149,62,0],[151,21,151,78,0],[152,21,152,22,0],[153,25,153,80,0],[156,25,156,32,0],[156,65,156,82,0],[156,34,156,61,0],[157,25,157,26,0],[158,29,158,84,0],[159,29,159,30,0],[160,33,160,93,0],[162,33,162,80,0],[163,33,163,81,0],[164,33,164,34,0],[165,37,165,46,0],[168,33,168,90,0],[170,33,170,100,0],[171,33,171,97,0],[173,33,173,95,0],[174,33,174,34,0],[175,37,175,53,0],[176,37,176,71,0],[177,37,177,68,0],[178,37,178,43,0],[180,29,180,30,0],[181,25,181,26,0],[156,62,156,64,0],[182,21,182,22,0],[183,17,183,18,0],[185,17,185,18,0],[186,21,186,65,0],[187,17,187,18,0],[188,13,188,14,0],[189,18,189,73,0],[190,13,190,14,0],[191,17,191,61,0],[192,13,192,14,0],[194,13,194,14,0],[195,17,195,53,0],[196,13,196,14,0],[198,13,198,27,0],[199,9,199,10,0]]);
    </script>
  </body>
</html>