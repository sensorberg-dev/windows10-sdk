<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\work\sensorberg\windows10-sdk\sensorbergsdk\internal\transport\requestqueue.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using MetroLog;
using SensorbergSDK.Internal.Services;

namespace SensorbergSDK.Internal
{
    /// &lt;summary&gt;
    /// Simple queue for requests. When a request is added, it is handled automatically in due time.
    /// &lt;/summary&gt;
    public sealed class RequestQueue:IDisposable
    {
        private static readonly ILogger logger = LogManagerFactory.DefaultLogManager.GetLogger&lt;RequestQueue&gt;();
        public event EventHandler&lt;int&gt; QueueCountChanged;
        private Task _workerTask;

        private readonly Queue&lt;Request&gt; _requestQueue;
        private CancellationTokenSource _cancelToken;

        public RequestQueue()
        {
            _requestQueue = new Queue&lt;Request&gt;();
        }

        /// &lt;summary&gt;
        /// Returns the element count inside the queue.
        /// &lt;/summary&gt;
        public int QueueSize
        {
            get { return _requestQueue.Count; }
        }

        /// &lt;summary&gt;
        /// Clears the queue while failing all pending requests.
        /// &lt;/summary&gt;
        public void Clear()
        {
            Cancel();

            // Abort all pending requests
            while (_requestQueue.Count &gt; 0)
            {
                OnRequestServed(_requestQueue.Dequeue(), RequestResultState.None);
            }
        }

        private void Cancel()
        {
            _cancelToken?.Cancel();
            _cancelToken?.Dispose();
            _cancelToken = null;
            _workerTask = null;
        }

        /// &lt;summary&gt;
        /// Adds an Requests to the queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt;
        public void Add(Request request)
        {
            _requestQueue.Enqueue(request);
            logger.Trace(&quot;Add new request {0}&quot;, request.RequestId);
            if (_requestQueue.Count &gt; 0 &amp;&amp;
                (_workerTask == null || _workerTask.Status == TaskStatus.Canceled || _workerTask.Status == TaskStatus.Faulted || _workerTask.Status == TaskStatus.RanToCompletion))
            {
                _cancelToken = new CancellationTokenSource();
                (_workerTask = Task.Run(ServeNextRequestAsync, _cancelToken.Token)).ConfigureAwait(false);
            }
            QueueCountChanged?.Invoke(this, _requestQueue.Count);
        }

        /// &lt;summary&gt;
        /// Serves the request in the current index.
        /// &lt;/summary&gt;
        private async Task ServeNextRequestAsync()
        {
            try
            {
                while (_requestQueue.Count != 0)
                {
                    Request currentRequest = _requestQueue.Dequeue();

                    if (currentRequest != null &amp;&amp; !currentRequest.IsBeingProcessed)
                    {
                        logger.Trace(&quot;RequestQueue: take next request &quot; + currentRequest.RequestId);
                        currentRequest.IsBeingProcessed = true;
                        currentRequest.TryCount++;
                        RequestResultState requestResult = RequestResultState.None;

                        try
                        {
                            requestResult = await ServiceManager.LayoutManager.ExecuteRequestAsync(currentRequest);
                        }
                        catch (ArgumentNullException ex)
                        {
                            currentRequest.ErrorMessage = ex.Message;
                            requestResult = RequestResultState.Failed;
                        }
                        catch (Exception ex)
                        {
                            currentRequest.ErrorMessage = ex.Message;
                            requestResult = RequestResultState.Failed;
                        }
                        logger.Debug(&quot;RequestQueue: request result &quot; + currentRequest.RequestId + &quot; &quot; + requestResult);

                        switch (requestResult)
                        {
                            case RequestResultState.Failed:
                            {
                                if (currentRequest.TryCount &gt;= currentRequest.MaxNumberOfRetries)
                                {
                                    // The maximum number of retries has been exceeded =&gt; fail
                                    OnRequestServed(currentRequest, requestResult);
                                }
                                else
                                {
                                    int numberOfTriesLeft = currentRequest.MaxNumberOfRetries - currentRequest.TryCount;

                                    logger.Debug(&quot;RequestQueue.ServeNextRequestAsync(): Request with ID &quot;
                                                 + currentRequest.RequestId + &quot; failed, will try &quot;
                                                 + numberOfTriesLeft + &quot; more &quot; + (numberOfTriesLeft &gt; 1 ? &quot;times&quot; : &quot;time&quot;));

                                    _requestQueue.Enqueue(currentRequest);
                                }

                            }
                                break;
                            case RequestResultState.Success:
                                OnRequestServed(currentRequest, requestResult);
                                break;
                        }

                        currentRequest.IsBeingProcessed = false;
                    }
                }
            }
            finally
            {
                Cancel();
            }
        }

        /// &lt;summary&gt;
        /// Sets the request result and removes it from the queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;resultState&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;True, if the request was successfully removed from the queue.&lt;/returns&gt;
        private void OnRequestServed(Request request, RequestResultState resultState)
        {
            if (request != null)
            {
                request.NotifyResult(resultState);

                if (_requestQueue.Count == 0 &amp;&amp; _cancelToken != null)
                {
                    Cancel();
                }
                QueueCountChanged?.Invoke(this, _requestQueue.Count);
            }
        }

        public void Dispose()
        {
            _cancelToken?.Dispose();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[44,13,44,14,0],[45,17,45,83,0],[46,13,46,14,0],[166,9,166,10,0],[167,13,167,37,0],[168,9,168,10,0],[96,25,96,57,0],[97,25,97,26,0],[98,29,98,70,0],[99,29,99,71,0],[100,25,100,26,0],[101,25,101,45,0],[102,25,102,26,0],[103,29,103,70,0],[104,29,104,71,0],[105,25,105,26,0],[22,9,22,30,1],[23,9,23,10,1],[24,13,24,50,1],[25,9,25,10,1],[32,17,32,18,1],[32,19,32,46,1],[32,47,32,48,1],[39,9,39,10,1],[40,13,40,22,1],[43,13,43,44,1],[47,9,47,10,1],[50,9,50,10,1],[51,13,51,36,1],[52,13,52,37,1],[53,13,53,33,1],[54,13,54,32,1],[55,9,55,10,1],[62,9,62,10,1],[63,13,63,44,1],[64,13,64,68,1],[65,13,66,180,1],[67,13,67,14,1],[68,17,68,62,1],[69,17,69,107,1],[70,13,70,14,1],[71,13,71,66,1],[72,9,72,10,1],[152,9,152,10,1],[153,13,153,33,1],[154,13,154,14,1],[155,17,155,51,1],[157,17,157,70,1],[158,17,158,18,1],[159,21,159,30,1],[160,17,160,18,1],[161,17,161,70,1],[162,13,162,14,1],[163,9,163,10,1],[15,9,15,112,1],[78,9,78,10,1],[80,13,80,14,1],[82,17,82,18,1],[83,21,83,70,1],[85,21,85,84,1],[86,21,86,22,1],[87,25,87,101,1],[88,25,88,64,1],[89,25,89,51,1],[90,25,90,84,1],[93,25,93,26,1],[94,29,94,116,1],[95,25,95,26,1],[106,25,106,120,1],[108,25,108,47,1],[111,29,111,30,1],[112,33,112,98,1],[113,33,113,34,1],[115,37,115,84,1],[116,33,116,34,1],[118,33,118,34,1],[119,37,119,121,1],[121,37,123,127,1],[125,37,125,75,1],[126,33,126,34,1],[128,29,128,30,1],[129,33,129,39,1],[131,33,131,80,1],[132,33,132,39,1],[135,25,135,65,1],[136,21,136,22,1],[137,17,137,18,1],[81,17,81,49,1],[138,13,138,14,1],[140,13,140,14,1],[141,17,141,26,1],[142,13,142,14,1],[143,9,143,10,1]]);
    </script>
  </body>
</html>