<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>d:\work\sensorberg\windows10-sdk\sensorbergsdk\internal\sdkengine.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using MetroLog;
using SensorbergSDK.Internal.Data;
using SensorbergSDK.Internal.Services;

namespace SensorbergSDK.Internal
{
    public class SDKEngine : IDisposable
    {
        private static readonly ILogger logger = LogManagerFactory.DefaultLogManager.GetLogger&lt;SDKEngine&gt;();
        private const int DelayedActionExecutionTimeframeInSeconds = 60;
        private const int UpdateVisibilityTimerIntervalInMilliseconds = 60000;
        private const int DatabaseExpirationInHours = 1;

        /// &lt;summary&gt;
        /// Fired when a beacon action has been successfully resolved and is ready to be exeuted.
        /// &lt;/summary&gt;
        public event EventHandler&lt;BeaconAction&gt; BeaconActionResolved;

        /// &lt;summary&gt;
        /// This event is fired, when a beacon actions could not be resolved.
        /// In most cases this event can be ignored.
        /// &lt;/summary&gt;
        public event EventHandler&lt;string&gt; FailedToResolveBeaconAction;

        /// &lt;summary&gt;
        /// Fired, when the layout becomes valid/invalid.
        /// &lt;/summary&gt;
        public event EventHandler&lt;bool&gt; LayoutValidityChanged;

        private readonly EventHistory _eventHistory;
        private Timer _processDelayedActionsTimer;
        private Timer _flushHistoryTimer;
        private Timer _updateVisibilityTimer;
        private Timer _getLayoutTimer;
//        private Timer _fetchActionsResolvedByBackgroundTimer;
        private DateTimeOffset _nextTimeToProcessDelayedActions;
        private readonly bool _appIsOnForeground;
        public AppSettings AppSettings { get; set; }

        public AppSettings DefaultAppSettings
        {
            [DebuggerStepThrough] get { return ServiceManager.SettingsManager.DefaultAppSettings; }
            [DebuggerStepThrough] set { ServiceManager.SettingsManager.DefaultAppSettings = value; }
        }

        /// &lt;summary&gt;
        /// Indicates whether the SDK engine is initialized and ready to function or not.
        /// &lt;/summary&gt;
        public bool IsInitialized { [DebuggerStepThrough] get; [DebuggerStepThrough] private set; }

        /// &lt;summary&gt;
        /// The Resolver instance.
        /// &lt;/summary&gt;
        public IResolver Resolver { [DebuggerStepThrough] get; [DebuggerStepThrough] private set; }

        /// &lt;summary&gt;
        /// Current count of unresolved actions
        /// &lt;/summary&gt;
        public int UnresolvedActionCount { [DebuggerStepThrough] get; [DebuggerStepThrough] private set; }

        public string UserId
        {
            [DebuggerStepThrough] get { return SDKData.Instance.UserId; }
            [DebuggerStepThrough] set { SDKData.Instance.UserId = value; }
        }

        /// &lt;summary&gt;
        /// Constructor.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;createdOnForeground&quot;&gt;&lt;/param&gt;
        public SDKEngine(bool createdOnForeground)
        {
            ServiceManager.Clear();
            ServiceManager.ApiConnction = new ApiConnection();
            ServiceManager.BeaconScanner = new Scanner();
            ServiceManager.LayoutManager = new LayoutManager();
            ServiceManager.StorageService = new StorageService(createdOnForeground);
            ServiceManager.SettingsManager = new SettingsManager();

            _appIsOnForeground = createdOnForeground;
            Resolver = createdOnForeground ? (IResolver) new Resolver() : new SyncResolver();
            _eventHistory = new EventHistory();
            _nextTimeToProcessDelayedActions = DateTimeOffset.MaxValue;
            UnresolvedActionCount = 0;
        }

        /// &lt;summary&gt;
        /// Initializes the SDK engine. 
        /// &lt;/summary&gt;
        public async Task InitializeAsync()
        {
            logger.Debug(&quot;InitializeAsync&quot;);
            if (!IsInitialized)
            {
                await ServiceManager.StorageService.InitStorage();

                ServiceManager.LayoutManager.LayoutValidityChanged += LayoutValidityChanged;

                // We force to update the cache on the foreground only
                await UpdateCacheAsync(_appIsOnForeground);

                Resolver.ActionsResolved -= OnBeaconActionResolvedAsync;
                Resolver.ActionsResolved += OnBeaconActionResolvedAsync;
                Resolver.FailedToResolveActions -= OnResolverFailedToResolveActions;
                Resolver.FailedToResolveActions += OnResolverFailedToResolveActions;

                if (_appIsOnForeground)
                {
                    logger.Debug(&quot;InitializeAsync#Foreground&quot;);
                    AppSettings = await ServiceManager.SettingsManager.GetSettings();
                    ServiceManager.SettingsManager.SettingsUpdated += OnSettingsUpdated;

                    var historyTimeSpan = TimeSpan.FromMilliseconds(AppSettings.HistoryUploadInterval);

                    _flushHistoryTimer =
                        new Timer(OnFlushHistoryTimerTimeoutAsync, null, historyTimeSpan, historyTimeSpan);

                    _updateVisibilityTimer =
                        new Timer(OnUpdateVisibilityTimerTimeout, null,
                            UpdateVisibilityTimerIntervalInMilliseconds,
                            UpdateVisibilityTimerIntervalInMilliseconds);

                    var layoutTimeSpam = TimeSpan.FromMilliseconds(AppSettings.LayoutUpdateInterval);
                    _getLayoutTimer = new Timer(OnLayoutUpdatedAsync, null, layoutTimeSpam, layoutTimeSpam);

                    // Check for possible delayed actions
                    await ProcessDelayedActionsAsync();
                    await CleanDatabaseAsync();
//                    await _eventHistory.FlushHistoryAsync();
                }

                IsInitialized = true;
            }
        }

        private void OnSettingsUpdated(object sender, SettingsEventArgs settingsEventArgs)
        {
            AppSettings = settingsEventArgs.Settings;

            var historyIntervalTimeSpan = TimeSpan.FromMilliseconds(AppSettings.HistoryUploadInterval);
            _flushHistoryTimer?.Change(historyIntervalTimeSpan, historyIntervalTimeSpan);

            var layoutUploadIntervalTimespan = TimeSpan.FromMilliseconds(AppSettings.LayoutUpdateInterval);
            _getLayoutTimer?.Change(layoutUploadIntervalTimespan, layoutUploadIntervalTimespan);
        }

        /// &lt;summary&gt;
        /// Updates the layout cache.
        /// &lt;/summary&gt;
        public async Task UpdateCacheAsync(bool forceUpdate)
        {
            await ServiceManager.LayoutManager.VerifyLayoutAsync(forceUpdate);
        }

        /// &lt;summary&gt;
        /// Tries to find a beacon action based on the given beacon event arguments.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;eventArgs&quot;&gt;The arguments of a beacon event.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public async Task ResolveBeaconAction(BeaconEventArgs eventArgs)
        {
            if (eventArgs == null)
            {
                return;
            }
            logger.Debug(&quot;SDKEngine: resolve beacon &quot; + eventArgs.Beacon.Id1 + &quot; &quot; + eventArgs.Beacon.Id2 + &quot; &quot; + eventArgs.Beacon.Id3 + &quot; &quot; + eventArgs.EventType);
            if (IsInitialized &amp;&amp; eventArgs.EventType != BeaconEventType.None)
            {
                UnresolvedActionCount++;
                await _eventHistory.SaveBeaconEventAsync(eventArgs);
                await Resolver.CreateRequest(eventArgs);
            }
        }

        /// &lt;summary&gt;
        /// Handles delayed beacon actions resolved earlier.
        /// &lt;/summary&gt;
        public async Task ProcessDelayedActionsAsync()
        {
            DateTimeOffset nearestDueTime = DateTimeOffset.MaxValue;

            IList&lt;DelayedActionData&gt; delayedActionDataList = await ServiceManager.StorageService.GetDelayedActions();

            foreach (DelayedActionData delayedActionData in delayedActionDataList)
            {
                if (delayedActionData.dueTime &lt; DateTimeOffset.Now.AddSeconds(DelayedActionExecutionTimeframeInSeconds))
                {
                    // Time to execute
                    await ExecuteActionAsync(delayedActionData.resolvedAction, delayedActionData.beaconPid, delayedActionData.eventTypeDetectedByDevice);
                    await ServiceManager.StorageService.SetDelayedActionAsExecuted(delayedActionData.Id);
                }
                else if (delayedActionData.dueTime &lt; nearestDueTime)
                {
                    nearestDueTime = delayedActionData.dueTime;
                }
            }
            if (_appIsOnForeground)
            {
                if (nearestDueTime &lt; DateTimeOffset.MaxValue)
                {
                    ResetProcessDelayedActionsTimer(nearestDueTime);
                }
                else if (_processDelayedActionsTimer != null)
                {
                    _processDelayedActionsTimer.Dispose();
                    _processDelayedActionsTimer = null;
                }
            }
        }

        /// &lt;summary&gt;
        /// Executes the given action, stores the event in event history and notifies the listeners.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;resolvedAction&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;beaconPid&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;beaconEventType&quot;&gt;&lt;/param&gt;
        private async Task ExecuteActionAsync(ResolvedAction resolvedAction, string beaconPid, BeaconEventType beaconEventType)
        {
            logger.Debug(&quot;SDKEngine: ExecuteActionAsync &quot; + beaconPid + &quot; BeaconEventType: &quot; + beaconEventType);
            bool checkOnlyOnce = await _eventHistory.CheckSendOnlyOnceAsync(resolvedAction);
            bool shouldSupress = await _eventHistory.ShouldSupressAsync(resolvedAction);

            logger.Trace(&quot;SDKEngine: ExecuteActionAsync &quot; + beaconPid + &quot; checkOnlyOnce: &quot; + checkOnlyOnce + &quot; shouldSupress:&quot; + shouldSupress);
            if (!shouldSupress &amp;&amp; !checkOnlyOnce &amp;&amp; resolvedAction.IsInsideTimeframes(DateTimeOffset.Now))
            {
                logger.Trace(&quot;SDKEngine: ExecuteActionAsync &quot; + beaconPid + &quot; action resolved&quot;);
                await _eventHistory.SaveExecutedResolvedActionAsync(resolvedAction.BeaconAction, beaconPid, beaconEventType);

                BeaconActionResolved?.Invoke(this, resolvedAction.BeaconAction);
            }
            else
            {
                logger.Trace(&quot;SDKEngine: ExecuteActionAsync &quot; + beaconPid + &quot; action not resolved&quot;);
            }
        }

        /// &lt;summary&gt;
        /// (Re)sets the process delayed actions timer to trigger based on the given due time.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;nextDueTime&quot;&gt;Time when the timer should timeout.&lt;/param&gt;
        private void ResetProcessDelayedActionsTimer(DateTimeOffset nextDueTime)
        {
            _processDelayedActionsTimer?.Dispose();

            int millisecondsToNextProcessingOfDelayedActions = (int) nextDueTime.Subtract(DateTimeOffset.Now).TotalMilliseconds;

            logger.Debug(&quot;SDKManager.ResetProcessDelayedActionsTimer(): &quot;
                                               + Math.Round((double) millisecondsToNextProcessingOfDelayedActions/1000, 0)
                                               + &quot; second(s) to next processing of delayed actions&quot;);

            _processDelayedActionsTimer =
                new Timer(OnProcessDelayedActionsTimerTimeoutAsync, null,
                    millisecondsToNextProcessingOfDelayedActions, Timeout.Infinite);
        }

        /// &lt;summary&gt;
        /// Cleans old entries from database. Called when the UI application is started.
        /// &lt;/summary&gt;
        private async Task CleanDatabaseAsync()
        {
            if (SDKData.Instance.DatabaseCleaningTime &lt; DateTimeOffset.Now.AddHours(-DatabaseExpirationInHours))
            {
                SDKData.Instance.DatabaseCleaningTime = DateTimeOffset.Now;
                await ServiceManager.StorageService.CleanDatabase();
            }
        }

        #region Private event handlers

        private async void OnBeaconActionResolvedAsync(object sender, ResolvedActionsEventArgs e)
        {
            if (e == null)
            {
                return;
            }
            logger.Debug(&quot;SDKEngine: OnBeaconActionResolvedAsync &quot; + e.RequestID + &quot; BeaconEventType:&quot; + e.BeaconEventType);
            //TODO verify event needed?
            if (e.ResolvedActions.Count &gt; 0)
            {
                foreach (ResolvedAction action in e.ResolvedActions)
                {
                    if (action.Delay &gt; 0 &amp;&amp; action.ReportImmediately == false)
                    {
                        logger.Debug(&quot;SDKEngine: OnBeaconActionResolvedAsync &quot; + e.RequestID + &quot; delay&quot;);
                        // Delay action execution
                        DateTimeOffset dueTime = DateTimeOffset.Now.AddSeconds((int) action.Delay);

                        await ServiceManager.StorageService.SaveDelayedAction(action, dueTime, e.BeaconPid, action.EventTypeDetectedByDevice);

                        if (_appIsOnForeground &amp;&amp; (_processDelayedActionsTimer == null || _nextTimeToProcessDelayedActions &gt; dueTime))
                        {
                            if (_nextTimeToProcessDelayedActions &gt; dueTime)
                            {
                                _nextTimeToProcessDelayedActions = dueTime;
                            }

                            ResetProcessDelayedActionsTimer(dueTime);
                        }
                    }
                    else
                    {
                        logger.Debug(&quot;SDKEngine: OnBeaconActionResolvedAsync/ExecuteActionAsync &quot; + e.RequestID + &quot; -&gt; Beacon Pid &quot; + e.BeaconPid);
                        // Execute action immediately
                        await ExecuteActionAsync(action, e.BeaconPid, e.BeaconEventType);
                    }
                }
            }
            UnresolvedActionCount--;
        }

        /// &lt;summary&gt;
        /// This method simply forwards the event to listeners.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;The error message.&lt;/param&gt;
        private void OnResolverFailedToResolveActions(object sender, string e)
        {
            FailedToResolveBeaconAction?.Invoke(this, e);
        }

        #endregion

        #region Timer callbacks


        /* /// &lt;summary&gt;
        /// Checks, if there are pending beacon actions resolved by the background task.
        /// This callback is called only when the application is on foreground.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;state&quot;&gt;&lt;/param&gt;
        public async void OnCheckActionsResolvedByBackground(object state)
        {
            if (SDKData.Instance.NewActionsFromBackground)
            {
                SDKData.Instance.NewActionsFromBackground = false;
                IList&lt;BeaconAction&gt; list = await ServiceManager.StorageService.GetBeaconActionsFromBackground();

                foreach (var beaconAction in list)
                {
                    if (BeaconActionResolved != null)
                    {
                        BeaconActionResolved(this, beaconAction);
                    }
                }
            }
        }*/

        private async void OnProcessDelayedActionsTimerTimeoutAsync(object state)
        {
            await ProcessDelayedActionsAsync();
        }

        private async void OnFlushHistoryTimerTimeoutAsync(object state)
        {
            logger.Debug(&quot;History flushed.&quot;);
            await _eventHistory.FlushHistoryAsync();
        }

        private async void OnLayoutUpdatedAsync(object state)
        {
            await UpdateCacheAsync(true);
        }

        private void OnUpdateVisibilityTimerTimeout(object state)
        {
            SDKData.Instance.AppIsVisible = SDKData.Instance.AppIsVisible;
        }

        #endregion

        public async Task FlushHistory()
        {
            await _eventHistory.FlushHistoryAsync();
        }

        public void Dispose()
        {
            _flushHistoryTimer?.Dispose();
            _getLayoutTimer?.Dispose();
            _processDelayedActionsTimer?.Dispose();
            _updateVisibilityTimer?.Dispose();

            if (IsInitialized)
            {
                ServiceManager.LayoutManager.LayoutValidityChanged -= LayoutValidityChanged;

                Resolver.ActionsResolved -= OnBeaconActionResolvedAsync;
                Resolver.FailedToResolveActions -= OnResolverFailedToResolveActions;
                Resolver.Dispose();

                IsInitialized = false;
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[47,39,47,40,0],[47,41,47,98,0],[47,99,47,100,0],[48,39,48,40,0],[48,41,48,99,0],[48,100,48,101,0],[68,39,68,40,0],[68,41,68,72,0],[68,73,68,74,0],[69,39,69,40,0],[69,41,69,73,0],[69,74,69,75,0],[142,9,142,10,0],[143,13,143,54,0],[145,13,145,104,0],[146,13,146,90,0],[148,13,148,108,0],[149,13,149,97,0],[150,9,150,10,0],[247,9,247,10,0],[248,13,248,52,0],[250,13,250,129,0],[252,13,254,102,0],[256,13,258,85,0],[259,9,259,10,0],[322,9,322,10,0],[323,13,323,58,0],[324,9,324,10,0],[370,9,370,10,0],[371,13,371,75,0],[372,9,372,10,0],[168,13,168,14,0],[169,17,169,24,0],[189,22,189,57,0],[190,13,190,14,0],[191,17,191,121,0],[192,17,192,18,0],[194,21,194,154,0],[195,21,195,106,0],[196,17,196,18,0],[197,22,197,69,0],[198,17,198,18,0],[199,21,199,64,0],[200,17,200,18,0],[201,13,201,14,0],[205,17,205,18,0],[206,21,206,69,0],[207,17,207,18,0],[209,17,209,18,0],[210,21,210,59,0],[211,21,211,56,0],[212,17,212,18,0],[267,13,267,14,0],[268,17,268,76,0],[269,17,269,69,0],[278,13,278,14,0],[279,17,279,24,0],[288,21,288,22,0],[289,25,289,106,0],[291,25,291,100,0],[293,25,293,143,0],[295,25,295,135,0],[296,25,296,26,0],[297,29,297,76,0],[298,29,298,30,0],[299,33,299,76,0],[300,29,300,30,0],[302,29,302,70,0],[303,25,303,26,0],[304,21,304,22,0],[354,9,354,10,0],[355,13,355,48,0],[356,9,356,10,0],[359,9,359,10,0],[360,13,360,46,0],[361,13,361,53,0],[362,9,362,10,0],[365,9,365,10,0],[366,13,366,42,0],[367,9,367,10,0],[377,9,377,10,0],[378,13,378,53,0],[379,9,379,10,0],[43,42,43,46,1],[43,47,43,51,1],[54,37,54,63,1],[54,64,54,98,1],[59,37,59,63,1],[59,64,59,98,1],[64,44,64,70,1],[64,71,64,105,1],[76,9,76,51,1],[77,9,77,10,1],[78,13,78,36,1],[79,13,79,63,1],[80,13,80,58,1],[81,13,81,64,1],[82,13,82,85,1],[83,13,83,68,1],[85,13,85,54,1],[86,13,86,94,1],[87,13,87,48,1],[88,13,88,72,1],[89,13,89,39,1],[90,9,90,10,1],[382,9,382,10,1],[383,13,383,43,1],[384,13,384,40,1],[385,13,385,52,1],[386,13,386,47,1],[388,13,388,31,1],[389,13,389,14,1],[390,17,390,93,1],[392,17,392,73,1],[393,17,393,85,1],[394,17,394,36,1],[396,17,396,39,1],[397,13,397,14,1],[398,9,398,10,1],[14,9,14,109,1],[96,9,96,10,1],[97,13,97,45,1],[98,13,98,32,1],[99,13,99,14,1],[100,17,100,67,1],[102,17,102,93,1],[105,17,105,60,1],[107,17,107,73,1],[108,17,108,73,1],[109,17,109,85,1],[110,17,110,85,1],[112,17,112,40,1],[113,17,113,18,1],[114,21,114,64,1],[115,21,115,86,1],[116,21,116,89,1],[118,21,118,104,1],[120,21,121,108,1],[123,21,126,74,1],[128,21,128,102,1],[129,21,129,109,1],[132,21,132,56,1],[133,21,133,48,1],[135,17,135,18,1],[137,17,137,38,1],[138,13,138,14,1],[139,9,139,10,1],[156,9,156,10,1],[157,13,157,79,1],[158,9,158,10,1],[166,9,166,10,1],[167,13,167,35,1],[171,13,171,165,1],[172,13,172,78,1],[173,13,173,14,1],[174,17,174,41,1],[175,17,175,69,1],[176,17,176,57,1],[177,13,177,14,1],[178,9,178,10,1],[184,9,184,10,1],[185,13,185,69,1],[187,13,187,118,1],[189,13,189,20,1],[189,61,189,82,1],[189,58,189,60,1],[202,13,202,36,1],[203,13,203,14,1],[204,17,204,62,1],[208,22,208,62,1],[213,13,213,14,1],[214,9,214,10,1],[223,9,223,10,1],[224,13,224,113,1],[225,13,225,93,1],[226,13,226,89,1],[228,13,228,145,1],[229,13,229,107,1],[230,13,230,14,1],[231,17,231,97,1],[232,17,232,126,1],[234,17,234,81,1],[235,13,235,14,1],[237,13,237,14,1],[238,17,238,101,1],[239,13,239,14,1],[240,9,240,10,1],[265,9,265,10,1],[266,13,266,113,1],[270,13,270,14,1],[271,9,271,10,1],[276,9,276,10,1],[277,13,277,27,1],[281,13,281,125,1],[283,13,283,45,1],[284,13,284,14,1],[285,17,285,24,1],[285,51,285,68,1],[285,26,285,47,1],[286,17,286,18,1],[287,21,287,79,1],[306,21,306,22,1],[307,25,307,148,1],[309,25,309,90,1],[310,21,310,22,1],[311,17,311,18,1],[285,48,285,50,1],[312,13,312,14,1],[313,13,313,37,1],[314,9,314,10,1]]);
    </script>
  </body>
</html>